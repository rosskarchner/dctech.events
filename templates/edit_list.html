{% extends "base.html" %}

{% block title %}Edit Events - {{ site_name }}{% endblock %}

{% block robots %}<meta name="robots" content="noindex, nofollow">{% endblock %}

{% block extra_head %}
<script type="importmap">
{
  "imports": {
    "octokit": "https://esm.sh/octokit@3.1.2"
  }
}
</script>
{% endblock %}

{% block content %}
<div class="edit-list-container">
    <h1>Edit Events</h1>

    <div id="auth-section">
        <p>To edit events, you'll need to sign in with a GitHub account. Don't have one? Just email the changes to ross@karchner.com.</p>

        <div class="auth-status" id="auth-status">
            <p>Not signed in</p>
            <button id="github-login" class="btn btn-primary">
                <svg height="16" width="16" viewBox="0 0 16 16" style="vertical-align: text-bottom; margin-right: 8px;">
                    <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                Sign in with GitHub
            </button>
        </div>
    </div>

    <div id="events-content" style="display: none;">
        <p>Select an event below to edit it. Check multiple events in the same time slot to merge duplicates, or check any events to assign categories.</p>

        <div id="filter-controls" class="filter-controls">
            <label>
                <input type="checkbox" id="filter-no-categories">
                Show only events without categories
                <span class="filter-count">({{ filter_stats.events_without_categories }})</span>
            </label>
            <label>
                <input type="checkbox" id="filter-manual-only">
                Show only manual events (hide iCal)
                <span class="filter-count">({{ filter_stats.manual_events_count }})</span>
            </label>
            <button id="clear-filters" class="btn btn-secondary btn-sm">Clear Filters</button>
            <span id="filtered-status" class="filtered-status"></span>
        </div>

        <div id="merge-controls" style="display: none;" class="merge-controls">
        <button id="merge-button" class="btn btn-warning">Merge Selected Duplicates</button>
        <span id="selected-count">0 selected</span>
    </div>

    <div id="category-controls" style="display: none;" class="category-controls">
        <label for="category-select">Assign category to selected events:</label>
        <select id="category-select">
            <option value="">-- Select Category --</option>
            {% for slug, cat in categories.items() %}
            <option value="{{ slug }}">{{ cat.name }}</option>
            {% endfor %}
        </select>
        <button id="apply-category-button" class="btn btn-primary">Apply to Selected</button>
        <span id="category-selected-count">0 selected</span>
    </div>

    {% if grouped_events %}
    <div class="events-list">
        {% for group in grouped_events %}
        <div class="time-slot-group {% if group.events|length > 1 %}has-multiple{% endif %}">
            <div class="time-slot-header">
                <strong>{{ group.date }}</strong>
                {% if group.time %}
                    at {{ group.time }}
                {% else %}
                    (All Day)
                {% endif %}
                {% if group.events|length > 1 %}
                    <span class="potential-duplicate">({{ group.events|length }} events)</span>
                {% endif %}
            </div>

            <div class="events-in-slot">
                {% for event in group.events %}
                <div class="event-row">
                    <div class="event-checkbox">
                        <input type="checkbox"
                               class="event-checkbox"
                               data-slot="{{ group.slot_key }}"
                               data-event-id="{{ event.guid or event.slug }}"
                               data-event-title="{{ event.title }}"
                               data-event-source="{{ event.source|default('unknown') }}"
                               data-event-categories="{{ event.categories|default([])|join(',') }}">
                    </div>

                    <div class="event-details">
                        <div class="event-title">
                            {{ event.title }}
                            {% if event.duplicate_of %}
                            <span class="duplicate-indicator">(duplicate of {{ event.duplicate_of[:8] }}...)</span>
                            {% endif %}
                        </div>
                        <div class="event-meta">
                            <span class="source-badge source-{{ event.source|default('unknown') }}">
                                {{ event.source|default('unknown') }}
                            </span>
                            {% if event.group %}
                            <span class="event-group">{{ event.group }}</span>
                            {% endif %}
                        </div>
                    </div>

                    <div class="event-actions">
                        <a href="/edit/event/{% if is_dev_mode %}?dev=true{% endif %}#{{ event.guid or event.slug }}"
                           class="btn btn-sm btn-primary">Edit</a>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>
    {% else %}
    <p class="no-events">No upcoming events to edit.</p>
    {% endif %}
    </div>
</div>

<!-- Merge Confirmation Modal -->
<div id="merge-modal" class="modal">
    <div class="modal-content">
        <h2>Merge Duplicates</h2>
        <div id="merge-preview"></div>
        <div class="modal-actions">
            <button id="confirm-merge" class="btn btn-primary">Create Pull Request</button>
            <button id="cancel-merge" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<style>
.edit-list-container {
    max-width: 1000px;
    margin: 2rem auto;
    padding: 0 1rem;
}

.merge-controls {
    background-color: #fef3c7;
    border: 2px solid #f59e0b;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.filter-controls {
    background-color: #f3f4f6;
    border: 2px solid #9ca3af;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
}

.filter-controls label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 500;
    cursor: pointer;
}

.filter-controls input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.filter-count {
    font-weight: 600;
    color: #6b7280;
    font-size: 0.875rem;
}

.filtered-status {
    font-weight: 600;
    color: #059669;
    margin-left: auto;
}

.time-slot-group.filtered-out {
    display: none;
}

.category-controls {
    background-color: #eff6ff;
    border: 2px solid #3b82f6;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
}

.category-controls label {
    font-weight: 600;
    color: #1e40af;
}

.category-controls select {
    padding: 0.5rem;
    border: 1px solid #93c5fd;
    border-radius: 4px;
    background-color: white;
}

#category-selected-count {
    font-weight: 600;
    color: #1e3a8a;
}

#selected-count {
    font-weight: 600;
    color: #92400e;
}

.events-list {
    margin-top: 2rem;
}

.time-slot-group {
    margin-bottom: 2rem;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    overflow: hidden;
}

.time-slot-group.has-multiple {
    border-color: #fbbf24;
    background-color: #fffbeb;
}

.time-slot-header {
    background-color: #f3f4f6;
    padding: 0.75rem 1rem;
    font-size: 0.875rem;
    border-bottom: 1px solid #e5e7eb;
}

.time-slot-group.has-multiple .time-slot-header {
    background-color: #fef3c7;
    border-bottom-color: #fbbf24;
}

.potential-duplicate {
    color: #b45309;
    font-weight: 600;
    margin-left: 0.5rem;
}

.events-in-slot {
    background-color: white;
}

.event-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid #f3f4f6;
}

.event-row:last-child {
    border-bottom: none;
}

.event-row:hover {
    background-color: #f9fafb;
}

.event-checkbox {
    flex-shrink: 0;
}

.event-checkbox input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.event-details {
    flex-grow: 1;
}

.event-title {
    font-weight: 500;
    margin-bottom: 0.25rem;
}

.duplicate-indicator {
    color: #dc2626;
    font-size: 0.875rem;
    font-weight: normal;
    font-style: italic;
}

.event-meta {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    font-size: 0.875rem;
}

.event-group {
    color: #6b7280;
}

.source-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
}

.source-manual {
    background-color: #dbeafe;
    color: #1e40af;
}

.source-ical {
    background-color: #f3e8ff;
    color: #6b21a8;
}

.source-eventbrite {
    background-color: #ffedd5;
    color: #c2410c;
}

.source-meetup {
    background-color: #d1fae5;
    color: #065f46;
}

.event-actions {
    flex-shrink: 0;
}

.btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    font-size: 0.875rem;
    font-weight: 600;
    cursor: pointer;
    text-decoration: none;
    display: inline-block;
    transition: all 0.2s;
}

.btn-primary {
    background-color: #2563eb;
    color: white;
}

.btn-primary:hover {
    background-color: #1d4ed8;
}

.btn-secondary {
    background-color: #e5e7eb;
    color: #374151;
}

.btn-secondary:hover {
    background-color: #d1d5db;
}

.btn-warning {
    background-color: #f59e0b;
    color: white;
}

.btn-warning:hover {
    background-color: #d97706;
}

.btn-sm {
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
}

.no-events {
    text-align: center;
    color: #9ca3af;
    padding: 3rem;
    font-size: 1.1rem;
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    align-items: center;
    justify-content: center;
}

.modal.active {
    display: flex;
}

.modal-content {
    background-color: white;
    padding: 2rem;
    border-radius: 8px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-content h2 {
    margin-top: 0;
    margin-bottom: 1.5rem;
}

#merge-preview {
    margin-bottom: 1.5rem;
}

.merge-preview-section {
    margin-bottom: 1.5rem;
}

.merge-preview-section h3 {
    font-size: 1rem;
    margin-bottom: 0.5rem;
    color: #374151;
}

.merge-primary {
    background-color: #d1fae5;
    border: 2px solid #059669;
    padding: 0.75rem;
    border-radius: 6px;
    margin-bottom: 0.5rem;
}

.merge-duplicate {
    background-color: #fee2e2;
    border: 2px solid #dc2626;
    padding: 0.75rem;
    border-radius: 6px;
    margin-bottom: 0.5rem;
}

.modal-actions {
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
}

.auth-status {
    background-color: #fef3c7;
    border: 1px solid #fbbf24;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
}

.auth-status.authenticated {
    background-color: #d1fae5;
    border-color: #10b981;
}
</style>

<script>
window.GITHUB_CONFIG = {
    clientId: '{{ github_client_id }}',
    callbackEndpoint: '{{ oauth_callback_endpoint }}'
};

window.CATEGORIES = {{ categories|tojson }};
</script>

<script type="module">
import { Octokit } from 'octokit';
import {
    REPO_CONFIG,
    ensureFork,
    createBranch,
    createOrUpdateFile,
    createPullRequest,
    generateDuplicateOverrideYAML,
    generateCategoryOverride,
    updateSingleEventCategory,
    fetchAllEvents
} from '/static/js/github-utils.js';

// GitHub OAuth Configuration
const CONFIG = {
    clientId: window.GITHUB_CONFIG?.clientId || '',
    callbackEndpoint: window.GITHUB_CONFIG?.callbackEndpoint || ''
};

// State management
let octokit = null;
let userData = null;
let allEvents = [];

// Track selected events for merging (slot-based)
const selectedEvents = new Map(); // slot_key -> Set of event IDs

// Track selected events for category assignment (global)
const categorySelections = new Set(); // Set of event IDs

// Filter state
const activeFilters = {
    noCategories: false,
    manualOnly: false
};

// Initialize auth on page load
initializeAuth();

/**
 * Initialize authentication state
 */
function initializeAuth() {
    const urlParams = new URLSearchParams(window.location.search);
    const accessToken = urlParams.get('access_token');

    if (accessToken) {
        sessionStorage.setItem('github_token', accessToken);
        window.history.replaceState({}, document.title, window.location.pathname);
        initializeOctokit(accessToken);
        return;
    }

    const storedToken = sessionStorage.getItem('github_token');
    if (storedToken) {
        initializeOctokit(storedToken);
    }
}

/**
 * Initialize Octokit with access token
 */
async function initializeOctokit(token) {
    try {
        octokit = new Octokit({ auth: token });
        const { data } = await octokit.rest.users.getAuthenticated();
        userData = data;
        console.log('Authenticated as:', userData.login);
        showAuthenticatedState();
    } catch (error) {
        console.error('Authentication error:', error);
        sessionStorage.removeItem('github_token');
    }
}

/**
 * Show authenticated state UI
 */
function showAuthenticatedState() {
    const authStatus = document.getElementById('auth-status');
    const eventsContent = document.getElementById('events-content');
    const authSectionP = document.querySelector('#auth-section > p');

    authStatus.className = 'auth-status authenticated';
    authStatus.innerHTML = `
        <p>✓ Signed in as <strong>${userData.login}</strong></p>
        <button id="sign-out" class="btn btn-secondary">Sign Out</button>
    `;
    document.getElementById('sign-out').addEventListener('click', handleSignOut);

    if (authSectionP) {
        authSectionP.style.display = 'none';
    }
    eventsContent.style.display = 'block';

    // Setup filter handlers
    setupFilterHandlers();
}

/**
 * Handle sign out
 */
function handleSignOut() {
    sessionStorage.removeItem('github_token');
    octokit = null;
    userData = null;
    window.location.reload();
}

/**
 * Handle GitHub login
 */
function handleGitHubLogin() {
    if (!CONFIG.clientId) {
        alert('GitHub OAuth is not configured.');
        return;
    }

    if (!CONFIG.callbackEndpoint) {
        alert('OAuth callback endpoint is not configured.');
        return;
    }

    // Create state object with CSRF token and return URL
    const stateObj = {
        csrf_token: crypto.randomUUID(),
        return_url: '/edit/',
        city: 'dc'
    };
    const state = btoa(JSON.stringify(stateObj));
    sessionStorage.setItem('oauth_state', stateObj.csrf_token);

    const authUrl = new URL('https://github.com/login/oauth/authorize');
    authUrl.searchParams.set('client_id', CONFIG.clientId);
    authUrl.searchParams.set('redirect_uri', CONFIG.callbackEndpoint);
    authUrl.searchParams.set('scope', 'public_repo');
    authUrl.searchParams.set('state', state);

    window.location.href = authUrl.toString();
}

// Set up login button handler
document.addEventListener('DOMContentLoaded', () => {
    const githubLoginBtn = document.getElementById('github-login');
    if (githubLoginBtn) {
        githubLoginBtn.addEventListener('click', handleGitHubLogin);
    }
});

// Update merge controls visibility
function updateMergeControls() {
    const mergeControls = document.getElementById('merge-controls');
    const mergeButton = document.getElementById('merge-button');
    const selectedCount = document.getElementById('selected-count');

    // Count slots with 2+ selections
    let totalSelected = 0;
    let slotsWithMultiple = 0;

    for (const [slot, eventIds] of selectedEvents.entries()) {
        if (eventIds.size >= 2) {
            slotsWithMultiple++;
            totalSelected += eventIds.size;
        }
    }

    if (slotsWithMultiple > 0) {
        mergeControls.style.display = 'flex';
        selectedCount.textContent = `${totalSelected} events selected across ${slotsWithMultiple} slot(s)`;
    } else {
        mergeControls.style.display = 'none';
    }
}

// Handle checkbox changes
document.addEventListener('DOMContentLoaded', () => {
    const checkboxes = document.querySelectorAll('.event-checkbox');

    checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const slot = e.target.dataset.slot;
            const eventId = e.target.dataset.eventId;

            if (e.target.checked) {
                // Add to category selections
                categorySelections.add(eventId);

                // Add to duplicate selections if in multi-event slot
                if (!selectedEvents.has(slot)) {
                    selectedEvents.set(slot, new Set());
                }
                selectedEvents.get(slot).add(eventId);
            } else {
                // Remove from both
                categorySelections.delete(eventId);

                if (selectedEvents.has(slot)) {
                    selectedEvents.get(slot).delete(eventId);
                    if (selectedEvents.get(slot).size === 0) {
                        selectedEvents.delete(slot);
                    }
                }
            }

            updateMergeControls();
            updateCategoryControls();
        });
    });

    // Handle merge button click
    document.getElementById('merge-button')?.addEventListener('click', showMergeConfirmation);

    // Handle category button click
    document.getElementById('apply-category-button')?.addEventListener('click', applyCategoryToEvents);

    // Handle modal buttons
    document.getElementById('cancel-merge')?.addEventListener('click', closeMergeModal);
    document.getElementById('confirm-merge')?.addEventListener('click', executeMerge);
});

function showMergeConfirmation() {
    const modal = document.getElementById('merge-modal');
    const preview = document.getElementById('merge-preview');

    preview.innerHTML = '';

    // Build preview for each slot
    for (const [slot, eventIds] of selectedEvents.entries()) {
        if (eventIds.size < 2) continue;

        const section = document.createElement('div');
        section.className = 'merge-preview-section';

        const slotTitle = document.createElement('h3');
        slotTitle.textContent = `Time Slot: ${slot}`;
        section.appendChild(slotTitle);

        // Get event data from checkboxes
        const events = Array.from(eventIds).map(id => {
            const checkbox = document.querySelector(`input[data-event-id="${id}"]`);
            return {
                id,
                title: checkbox.dataset.eventTitle,
                source: checkbox.dataset.eventSource
            };
        });

        // Determine primary (prefer manual, otherwise first)
        const primaryEvent = events.find(e => e.source === 'manual') || events[0];
        const duplicates = events.filter(e => e.id !== primaryEvent.id);

        // Display primary
        const primaryDiv = document.createElement('div');
        primaryDiv.className = 'merge-primary';
        primaryDiv.innerHTML = `<strong>✓ Primary Event:</strong> ${primaryEvent.title} (${primaryEvent.source})`;
        section.appendChild(primaryDiv);

        // Display duplicates
        duplicates.forEach(dup => {
            const dupDiv = document.createElement('div');
            dupDiv.className = 'merge-duplicate';
            dupDiv.innerHTML = `<strong>× Will be marked as duplicate:</strong> ${dup.title} (${dup.source})`;
            section.appendChild(dupDiv);
        });

        preview.appendChild(section);
    }

    modal.classList.add('active');
}

function closeMergeModal() {
    const modal = document.getElementById('merge-modal');
    modal.classList.remove('active');
}

async function executeMerge() {
    // Check authentication
    if (!octokit || !userData) {
        alert('Please sign in with GitHub to merge duplicates.');
        // Redirect to OAuth
        if (CONFIG.clientId) {
            const authUrl = new URL('https://github.com/login/oauth/authorize');
            authUrl.searchParams.set('client_id', CONFIG.clientId);
            authUrl.searchParams.set('redirect_uri', CONFIG.callbackEndpoint);
            authUrl.searchParams.set('scope', 'public_repo');
            window.location.href = authUrl.toString();
        }
        return;
    }

    closeMergeModal();

    const statusDiv = document.createElement('div');
    statusDiv.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #eff6ff; border: 2px solid #3b82f6; padding: 1rem; border-radius: 8px; z-index: 10000; max-width: 300px;';
    statusDiv.innerHTML = '<strong>Creating Pull Request...</strong><p>Please wait...</p>';
    document.body.appendChild(statusDiv);

    try {
        // Load all events to get full event data
        if (allEvents.length === 0) {
            statusDiv.innerHTML = '<strong>Loading events...</strong>';
            allEvents = await fetchAllEvents();
        }

        // Collect merge operations
        const mergeOperations = [];
        for (const [slot, eventIds] of selectedEvents.entries()) {
            if (eventIds.size < 2) continue;

            // Get full event data
            const events = Array.from(eventIds).map(id => {
                const event = allEvents.find(e => (e.guid || e.slug) === id);
                const checkbox = document.querySelector(`input[data-event-id="${id}"]`);
                return {
                    id,
                    title: checkbox.dataset.eventTitle,
                    source: checkbox.dataset.eventSource,
                    fullData: event
                };
            });

            // Determine primary (prefer manual, otherwise first)
            const primaryEvent = events.find(e => e.source === 'manual') || events[0];
            const duplicates = events.filter(e => e.id !== primaryEvent.id);

            mergeOperations.push({
                slot,
                primary: primaryEvent,
                duplicates
            });
        }

        // Ensure fork exists
        statusDiv.innerHTML = '<strong>Checking fork...</strong>';
        await ensureFork(octokit, userData);

        // Create branch
        const branchName = `merge-duplicates-${Date.now()}`;
        statusDiv.innerHTML = '<strong>Creating branch...</strong>';
        await createBranch(octokit, userData, branchName);

        // Create override files for each duplicate
        statusDiv.innerHTML = '<strong>Creating override files...</strong>';
        const overrideFiles = [];

        for (const operation of mergeOperations) {
            for (const duplicate of operation.duplicates) {
                const filePath = `_event_overrides/${duplicate.id}.yaml`;
                const yamlContent = generateDuplicateOverrideYAML(operation.primary.id);

                await createOrUpdateFile(
                    octokit,
                    userData,
                    branchName,
                    filePath,
                    yamlContent,
                    `Mark ${duplicate.title} as duplicate of ${operation.primary.title}`
                );

                overrideFiles.push({
                    duplicate: duplicate.title,
                    primary: operation.primary.title,
                    file: filePath
                });
            }
        }

        // Generate PR body
        const prBody = `## Merge Duplicate Events

This PR marks ${overrideFiles.length} event(s) as duplicates:

${overrideFiles.map(f => `- **${f.duplicate}** → duplicate of **${f.primary}**\n  File: \`${f.file}\``).join('\n')}

---
Submitted via web interface by @${userData.login}`;

        // Create pull request
        statusDiv.innerHTML = '<strong>Creating pull request...</strong>';
        const prUrl = await createPullRequest(
            octokit,
            userData,
            branchName,
            `Merge duplicate events (${overrideFiles.length} duplicates)`,
            prBody
        );

        // Show success
        statusDiv.innerHTML = `<strong>✓ Success!</strong><p>Pull request created: <a href="${prUrl}" target="_blank">View PR</a></p>`;
        setTimeout(() => statusDiv.remove(), 10000);

        // Clear selections
        selectedEvents.clear();
        document.querySelectorAll('.duplicate-checkbox:checked').forEach(cb => cb.checked = false);
        updateMergeControls();

    } catch (error) {
        console.error('Error creating merge PR:', error);
        statusDiv.innerHTML = `<strong>❌ Error</strong><p>${error.message}</p>`;
        setTimeout(() => statusDiv.remove(), 10000);
    }
}

// Update category controls visibility
function updateCategoryControls() {
    const categoryControls = document.getElementById('category-controls');
    const selectedCount = document.getElementById('category-selected-count');

    const count = categorySelections.size;

    if (count > 0) {
        categoryControls.style.display = 'flex';
        selectedCount.textContent = `${count} event${count !== 1 ? 's' : ''} selected`;
    } else {
        categoryControls.style.display = 'none';
    }
}

// Apply category to selected events
async function applyCategoryToEvents() {
    const category = document.getElementById('category-select').value;
    const eventIds = Array.from(categorySelections);

    if (!category) {
        alert('Please select a category');
        return;
    }

    if (eventIds.length === 0) {
        alert('Please select at least one event');
        return;
    }

    // Check authentication
    if (!octokit || !userData) {
        alert('Please sign in with GitHub to apply categories.');
        return;
    }

    const statusDiv = document.createElement('div');
    statusDiv.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #eff6ff; border: 2px solid #3b82f6; padding: 1rem; border-radius: 8px; z-index: 10000; max-width: 300px;';
    statusDiv.innerHTML = '<strong>Creating Pull Request...</strong><p>Please wait...</p>';
    document.body.appendChild(statusDiv);

    try {
        // Load all events to get full event data
        if (allEvents.length === 0) {
            statusDiv.innerHTML = '<strong>Loading events...</strong>';
            allEvents = await fetchAllEvents();
        }

        // Ensure fork exists
        statusDiv.innerHTML = '<strong>Checking fork...</strong>';
        await ensureFork(octokit, userData);

        // Create branch
        const branchName = `categorize-events-${Date.now()}`;
        statusDiv.innerHTML = '<strong>Creating branch...</strong>';
        await createBranch(octokit, userData, branchName);

        // Update event files (either _single_events/ or _event_overrides/)
        statusDiv.innerHTML = '<strong>Updating event files...</strong>';
        const updatedEvents = [];

        for (const eventId of eventIds) {
            const event = allEvents.find(e => (e.guid || e.id) === eventId);

            // Check if this is a manually submitted event (source='manual', from _single_events/)
            // vs an iCal event (source='ical', needs override in _event_overrides/)
            if (event.source === 'manual' && event.id) {
                // This is a manually submitted event in _single_events/
                const filePath = `_single_events/${event.id}.yaml`;
                const yamlContent = await updateSingleEventCategory(octokit, userData, branchName, event.id, category);

                await createOrUpdateFile(
                    octokit, userData, branchName, filePath, yamlContent,
                    `Add ${category} category to ${event.title}`
                );
            } else {
                // This is an iCal event, use override mechanism
                const filePath = `_event_overrides/${eventId}.yaml`;
                const yamlContent = await generateCategoryOverride(octokit, userData, branchName, eventId, category);

                await createOrUpdateFile(
                    octokit, userData, branchName, filePath, yamlContent,
                    `Add ${category} category to ${event.title}`
                );
            }

            updatedEvents.push(event.title);
        }

        // Generate PR body
        const prBody = `## Bulk Category Assignment

Assigned category **${category}** to ${updatedEvents.length} event(s):

${updatedEvents.map(t => `- ${t}`).join('\n')}

---
Submitted via web interface by @${userData.login}`;

        // Create pull request
        statusDiv.innerHTML = '<strong>Creating pull request...</strong>';
        const prUrl = await createPullRequest(
            octokit, userData, branchName,
            `Assign ${category} category to ${updatedEvents.length} events`,
            prBody
        );

        // Show success
        statusDiv.innerHTML = `<strong>✓ Success!</strong><p>Pull request created: <a href="${prUrl}" target="_blank">View PR</a></p>`;
        setTimeout(() => statusDiv.remove(), 10000);

        // Clear selections
        categorySelections.clear();
        document.querySelectorAll('.event-checkbox:checked').forEach(cb => cb.checked = false);
        updateCategoryControls();
        updateMergeControls();
        document.getElementById('category-select').value = '';

    } catch (error) {
        console.error('Error creating category PR:', error);
        statusDiv.innerHTML = `<strong>❌ Error</strong><p>${error.message}</p>`;
        setTimeout(() => statusDiv.remove(), 10000);
    }
}

/**
 * Setup filter handlers
 */
function setupFilterHandlers() {
    const filterNoCategories = document.getElementById('filter-no-categories');
    const filterManualOnly = document.getElementById('filter-manual-only');
    const clearFiltersBtn = document.getElementById('clear-filters');

    if (filterNoCategories) {
        filterNoCategories.addEventListener('change', (e) => {
            activeFilters.noCategories = e.target.checked;
            applyFilters();
        });
    }

    if (filterManualOnly) {
        filterManualOnly.addEventListener('change', (e) => {
            activeFilters.manualOnly = e.target.checked;
            applyFilters();
        });
    }

    if (clearFiltersBtn) {
        clearFiltersBtn.addEventListener('click', () => {
            activeFilters.noCategories = false;
            activeFilters.manualOnly = false;
            if (filterNoCategories) filterNoCategories.checked = false;
            if (filterManualOnly) filterManualOnly.checked = false;
            applyFilters();
        });
    }
}

/**
 * Apply active filters to event list
 */
function applyFilters() {
    const timeSlotGroups = document.querySelectorAll('.time-slot-group');
    const filteredStatus = document.getElementById('filtered-status');
    let visibleEventsCount = 0;
    let totalEventsCount = 0;

    timeSlotGroups.forEach(group => {
        const eventRows = group.querySelectorAll('.event-row');
        let visibleInSlot = 0;

        eventRows.forEach(row => {
            totalEventsCount++;
            const checkbox = row.querySelector('input.event-checkbox');
            const categories = checkbox.dataset.eventCategories || '';
            const source = checkbox.dataset.eventSource || '';

            let shouldShow = true;

            // Apply noCategories filter
            if (activeFilters.noCategories) {
                // Hide events that have categories
                if (categories && categories.trim() !== '') {
                    shouldShow = false;
                }
            }

            // Apply manualOnly filter (AND logic)
            if (activeFilters.manualOnly && shouldShow) {
                // Hide events that are not manual
                if (source !== 'manual') {
                    shouldShow = false;
                }
            }

            // Show/hide the event row
            if (shouldShow) {
                row.style.display = '';
                visibleInSlot++;
                visibleEventsCount++;
            } else {
                row.style.display = 'none';
            }
        });

        // Hide time slot if no visible events
        if (visibleInSlot === 0) {
            group.classList.add('filtered-out');
        } else {
            group.classList.remove('filtered-out');
        }
    });

    // Update filtered status message
    if (activeFilters.noCategories || activeFilters.manualOnly) {
        filteredStatus.textContent = `Showing ${visibleEventsCount} of ${totalEventsCount} events`;
    } else {
        filteredStatus.textContent = '';
    }
}
</script>
{% endblock %}
